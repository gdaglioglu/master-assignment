+------------------------------------------------------------------------------+
|     Luke Potter's URLyBird application design and implementation choices     |
+------------------------------------------------------------------------------+

Table of Contents:
1. Code style
2. Networking decisions
3. Database decisions
4. Property file decisions
5. Concurrency and locking decisions
6. GUI and usability decisions
7. General decision and considerations






1. Code style

JavaDoc:



Class and Method naming:



Code Style:
One of the requirements of the project was to write code that a junior
programmer could easily understand. I think I completed this requirement.

I've used many one-liner statements in this project.

Instead of:
    public int sumNumbers(int x, int y) {
        int sum = x + y;
        return sum;
    }

I've used:
    public int sumNumbers(int x, int y) {
        return x + y;
    }

I see my responsibility as a mentor of junior programmers to demonstrate how to
write clear, concise code and eliminate redundant lines of code.







2. Networking decisions

RMI vs Sockets:



RMI Implementation:
I decided to use RMI in this implementation of URLyBird. Rather than use a RMI
Factory Pattern, I used the suncertify.controller.DatabaseAccessDaoRemote object
to handle the communication across the network. Each Networked Client GUI gets a
reference to a DatabaseAccessDaoRemote object, which it uses to make the remote
calls to the database, via the server.

The server needs to be running for the clients to connect to it.

The server and it's clients need to same RMI URL to connect to each other. The
suncertify.properties file must have entries which allow the server and client
to form the correct RMI URL.

Example of the required entries in suncertify.properties.
    rmiHostname=localhost
    rmiPortNumber=1234

The server, along with the RMI URL properties, needs the location of the
database specified.

Example of the required entries in suncertify.properties.
    pathToDatabaseFile=db-1x1.db

DAO Pattern:



Extra Remote Interface:







3. Database decisions

Object Orientated Approach:



Facade Pattern:




Record Creation Process:
When the CSR wants to create a record, it is appended to the end of the Database
file.


Record Deletion Process:
When the CSR want to delete a record, only the bit at the start of the record
changed. The contents of the record are still present in the database file.


Random Access File:


Caching Records:


Limitations:







4. Property file decisions

Property Management:



Required Properties:
The properties file must be in the current user directory. It must be called
"suncertify.properties".

I decided to use three properties in the application;
  * pathToDatabaseFile
  * rmiHostname
  * rmiPortNumber

These three properties must be present in the suncertify.properties file for the
server to function.
The standalone client only requires the "pathToDatabaseFile" property.
The networked client requires both the "rmiHostname" and "rmiPortNumber" to be
present.

Example of the suncertify.properties.
    pathToDatabaseFile=db-1x1.db
    rmiHostname=localhost
    rmiPortNumber=1234







5. Concurrency and locking decisions

In the provided interface file, suncertify.db.DBAccess, the lockRecord() and
unlock() methods are implemented by suncertify.db.Data. The Data class is a
facade, so the logic for the lockRecord() and unlock() methods is located in
suncertify.db.DatabaseAccessLockManager.

DatabaseAccessLockManager is a singleton class. It's public interface, for
locking and unlocking records has four synchronised methods;
  * lock
  * unlock
  * lockRecordWhenCreatingNewRecord
  * unlockRecordWhenCreatingOrDeletingRecord

The lock() and unlock() methods are for obtaining a lock on records that already
exist, and that will exist after the intervening operations have been completed.
So these methods are useful for obtaining lock when updating and reading
records.

The lockRecordWhenCreatingNewRecord() and
unlockRecordWhenCreatingOrDeletingRecord() methods are for obtaining locks on
records that do not yet exists, or that will not exist after the intervening
operation have been completed. These methods are useful for obtaining lock when
creating and deleting records.

DatabaseAccessLockManager has a HashMap that maps record numbers to lock
cookies.

When trying to lock a record it checks if the record is in the HashMap.
If the record is present, it waits, until the HashMap entry is no longer there.
It then puts the entry in the HashMap, thereby obtaining the lock.

When trying to unlock a record it checks if there is an entry in the HashMap for
the record and cookie. It then removes the record, there by releasing the lock.







6. GUI and usability decisions

Logging into the Client GUI:
When opening the Client GUI, you will be prompted for your CSR number. This will
be the id used to book rows for the duration of this GUI's existence. Asking for
the CSR number at the start eliminates the process of having to repeatedly enter
it when booking.

Client GUI's Table of Records:
The Client GUI is populated with a table of records. These are the valid records
that are present in the database file. The "Date Available" column will display
the date that the room is available on, if that date is in the future. Otherwise
it will presume that the room's booking has expires and display "Available". I
think that this is a good feature, as it displays the information in as an
easily recognisable way to distinguish between the booked and available records.

There is one issue, if the room is showing "Available", it may also show the CSR
number of the last user to book that room. This is because there is no process
that is constantly checking the database for expired bookings and deleting the
CSR number from these records.


Client GUI's Search Function:
I'm only allowing the user to search on the name and location of the Hotel they
would like to book into. I'm implementing the search function this way, as a CSR
may have request for a specific Hotel franchise, or the hotels available in a
location.

The search feature compares the criteria values specified to every record in the
database. When making the comparison it uses the lowercase equivalents of the
strings. Utilising a common case for as a basis for comparison, expands beyond
the requirement, "Fred" matches "Fred" or "Freddy". This means that "fred"
matches "fred", "freddy", "Fred" or "Freddy". I implemented it this way, as some
users may enter lowercase characters, expecting that the search function will
return the same result for "Fred" and "fred". I catered for these users.

I decided against implementing price search logic, as that's not a "must"
feature.


Booking a Room using the Client GUI:
When booking a room a row in the table must be selected. A dialog box will pop
up, and ask for the CSR which day they would like the booking to start on, this
is to enforce the 48 hour booking start time requirement. Overall this choice of
"Today" or "Tomorrow" has no effect on the application.

After choosing the start date, the user is prompted for the end date of the
booking. This must be in the format "yyyy/MM/DD", e.g. "2014/05/30" for May 30th
2014.

The record is then booked and the table is refreshed for the booking GUI.


Refreshing the Client GUI's table of records:
In a situation where multiple clients are booking rooms, it is necessary to have
up to have the latest information on which rooms are free.

To refresh your GUI's table records;
  1. Clear the "Name" and "Location" Text Fields.
  2. Click the "Search" Button.



Future Client GUI Enhancements:
I built the GUIs, client and server, out of panels, where it was possible. This
will allow the GUIs to be extended in future. Create the newly extended JPanel
class and add it to the UrlyBirdClientGui, or UrlyBirdServerGui, class.

Should functionality to create, edit and delete records be added to the Client
GUI in future, it should be relatively straight forward to add them to the GUI.

The implementation of an Observer, or MVC, pattern would allow the table of
records on all client GUIs to be updated after any client makes booking.

When viewing a search result, there is an issue when trying to make a booking.
Say a search returns three results, and the client tries to book result number
three. Only the table row number is recorded, so record three in the database
will be booked. This is an area for future enhancement of the GUI.


Server GUI:
The server GUI has three text fields, representing an entry in the
suncertify.properties file. The server GUI will be preloaded with the
properties, if the properties file is present. Otherwise it will be blank. The
server will not start unless the suncertify.properties file is present and
pre-populated with values.

Example of the suncertify.properties.
    pathToDatabaseFile=db-1x1.db
    rmiHostname=localhost
    rmiPortNumber=1234




7. General decision and considerations





