+------------------------------------------------------------------------------+
|     Luke Potter's URLyBird application design and implementation choices     |
+------------------------------------------------------------------------------+

Table of Contents:
------------------
1. Code style
2. Networking decisions
3. Database decisions
4. Property file decisions
5. Concurrency and locking decisions
6. GUI and usability decisions
7. General decision and considerations
--------------------------------------------------------------------------------

1. Code style

One of the requirements of the project was to write code that a junior
programmer could easily understand. I think I completed this requirement.

I've used many one-liner statements in this project.

Instead of:
    public int sumNumbers(int x, int y) {
        int sum = x + y;
        return sum;
    }

I've used:
    public int sumNumbers(int x, int y) {
        return x + y;
    }

I see my responsibility as a mentor of junior programmers to demonstrate how to
write clear, concise code and eliminate redundant lines of code.

--------------------------------------------------------------------------------

2. Networking decisions

I decided to use RMI in this implementation of URLyBird. Rather than use a RMI
Factory Pattern, I used the suncertify.controller.DatabaseAccessDaoRemote object
to handle the communication across the network. Each Networked Client GUI gets a
reference to a DatabaseAccessDaoRemote object, which it uses to make the remote
calls to the database, via the server.

The server needs to be running for the clients to connect to it.

The server and it's clients need to same RMI URL to connect to each other. The
suncertify.properties file must have entries which allow the server and client
to form the correct RMI URL.

Example of the required entries in suncertify.properties.
    rmiHostname=localhost
    rmiPortNumber=1234

The server, along with the RMI URL properties, needs the location of the
database specified.

Example of the required entries in suncertify.properties.
    pathToDatabaseFile=db-1x1.db

--------------------------------------------------------------------------------

3. Database decisions

Record Creation Process:
------------------------
When the CSR wants to create a record, it is appended to the end of the Database
file.

Record Deletion Process:
------------------------
When the CSR want to delete a record, only the bit at the start of the record
changed. The contents of the record are still present in the database file.

--------------------------------------------------------------------------------

4. Property file decisions

The properties file must be in the current user directory. It must be called
"suncertify.properties".

I decided to use three properties in the application;
  * pathToDatabaseFile
  * rmiHostname
  * rmiPortNumber

These three properties must be present in the suncertify.properties file for the
server to function.
The standalone client only requires the "pathToDatabaseFile" property.
The networked client requires both the "rmiHostname" and "rmiPortNumber" to be
present.

Example of the suncertify.properties.
    pathToDatabaseFile=db-1x1.db
    rmiHostname=localhost
    rmiPortNumber=1234

--------------------------------------------------------------------------------

5. Concurrency and locking decisions

In the provided interface file, suncertify.db.DBAccess, the lockRecord() and
unlock() methods are implemented by suncertify.db.Data. The Data class is a
facade, so the logic for the lockRecord() and unlock() methods is located in
suncertify.db.DatabaseAccessLockManager.

DatabaseAccessLockManager is a singleton class. It's public interface, for
locking and unlocking records has four synchronised methods;
  * lock
  * unlock
  * lockRecordWhenCreatingNewRecord
  * unlockRecordWhenCreatingOrDeletingRecord

The lock() and unlock() methods are for obtaining a lock on records that already
exist, and that will exist after the intervening operations have been completed.
So these methods are useful for obtaining lock when updating and reading
records.

The lockRecordWhenCreatingNewRecord() and
unlockRecordWhenCreatingOrDeletingRecord() methods are for obtaining locks on
records that do not yet exists, or that will not exist after the intervening
operation have been completed. These methods are useful for obtaining lock when
creating and deleting records.

DatabaseAccessLockManager has a HashMap that maps record numbers to lock
cookies.

When trying to lock a record it checks if the record is in the HashMap.
If the record is present, it waits, until the HashMap entry is no longer there.
It then puts the entry in the HashMap, thereby obtaining the lock.

When trying to unlock a record it checks if there is an entry in the HashMap for
the record and cookie. It then removes the record, there by releasing the lock.

--------------------------------------------------------------------------------

6. GUI and usability decisions

Logging into the GUI:
---------------------
When opening the Client GUI, you will be prompted for your CSR number. This will
be the id used to book rows for the duration of this GUI's existence. Asking for
the CSR number at the start eliminates the process of having to repeatedly enter
it when booking.

Search Function:
----------------
I'm only allowing the user to search on the name and location of the Hotel they
would like to book into. I'm implementing the search function this way, as a CSR
may have request for a specific Hotel franchise, or the hotels available in a
location.

The search feature compares the criteria values specified to every record in the
database. When making the comparison it uses the lowercase equivalents of the
strings. Utilising a common case for as a basis for comparison, expands beyond
the requirement, "Fred" matches "Fred" or "Freddy". This means that "fred"
matches "fred", "freddy", "Fred" or "Freddy". I implemented it this way, as some
users may enter lowercase characters, expecting that the search function will
return the same result for "Fred" and "fred". I catered for these users.

I decided against implementing price search logic, as that's not a "must"
feature.

Booking a Room:
---------------
When booking a room a row in the table must be selected. A dialog box will pop
up, and ask for the CSR which day they would like the booking to start on, this
is to enforce the 48 hour booking start time requirement. Overall this choice of
"Today" or "Tomorrow" has no effect on the application.

After choosing the start date, the user is prompted for the end date of the
booking. This must be in the format "yyyy/MM/DD", e.g. "2014/05/30" for May 30th
2014.

The record is then booked and the table is refreshed for the booking GUI.

Refreshing the client GUI:
--------------------------
In a situation where multiple clients are booking rooms, it is necessary to have
up to have the latest information on which rooms are free.

To refresh your GUI's table records;
  1. Clear the "Name" and "Location" Text Fields.
  2. Click the "Search" Button.


Future GUI Enhancements:
------------------------
I built the GUIs, client and server, out of panels, where it was possible. This
will allow the GUIs to be extended in future. Create the newly extended JPanel
class and add it to the UrlyBirdClientGui, or UrlyBirdServerGui, class.

Should functionality to create, edit and delete records be added to the Client
GUI in future, it should be relatively straight forward to add them to the GUI.

The implementation of an Observer, or MVC, pattern would allow the table of
records on all client GUIs to be updated after any client makes booking.

When viewing a search result, there is an issue when trying to make a booking.
Say a search returns three results, and the client tries to book result number
three. Only the table row number is recorded, so record three in the database
will be booked. This is an area for future enhancement of the GUI.

--------------------------------------------------------------------------------

7. General decision and considerations

--------------------------------------------------------------------------------